<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <style>
        /* 카카오 채팅창 css */

        :root { 
            font-size: 16px;
            /* 말풍선 전체 컨테이너 마진 */
            --chat-container-margin: 0.5rem 0.8rem;
            /* 상대방 프로필 이미지 굴곡 */
            --profile-img-radius: 1.5rem;
            /* 아이디 + 대화 텍스트 + 시간 컨테이너 마진        */
            --chat-contents-wrapper-margin: 0rem 0.6rem;
            /* 대화 텍스트 + 시간 컨테이너 높이 */
            --chat-box-basis: 3rem;
            /* 대화 시간 + 상대방 아이디 텍스트 컬러 */
            --chat-info-color: #555c62;
            /* 대화 시간 마진 */
            --chat-time-margin: 0rem 0.3rem;
            /* 대화 텍스트 패딩 */
            --chat-padding: 0.6rem 0.6rem;
            /* 대화 텍스트 굴곡 */
            --chat-radius: 15px;
            /* 대화 텍스트 스타일 */
            --chat-font: 1.2rem "Fira Sans", sans-serif;
        }


        body {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;

        }

        
        /*  카톡창 전체     */
        .container {    
            width: 400px;
            height: 800px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background-color: #afc0cf;

            /* remove later */
            border: 1px solid red;

        }

        /* 상단 스마트폰 상태창 + 상단 카톡방 정보창 */
        header > div {
            font-weight: bold;

            display: flex;
            padding: 0.5rem 0rem;
            justify-content: space-between;
        }

        /* 스마트폰 정보 아이콘 + 카톡방 검색 and 햄버거 메뉴 아이콘 */
        /* TODO: 높이 중앙 정렬 */
        header img {
            width: 1.5rem;
            height: auto;
            
        }

        /* 상단 스마트폰 상태창 */
        .device-info {
            align-items: center;
            margin: 0rem 2rem;
        }

        /* 상단 스마트폰 상태창 아이콘 */
        .device-info img {
            margin: 0rem 0.15rem;
        }

        /* 상단 카톡방 정보창 */
        .chat-info {
            margin: 0rem 1rem;
            align-items: center;
        }

        /* 상단 카톡방 정보창 아이콘 이미지 랩퍼 */
        .chat-info > span > span {
            margin: 0rem 0.4rem;
        }


        /* 카톡방 대화창 전체 */
        .chat-container {
            display: flex;
            flex-direction: column;
            overflow-y: scroll; /*  말풍선이 많아져서 컨테이너를 넘쳤을 경우 스크롤해서 보여주기 */
        }

        /* 카톡방 대화창 전체 스크롤바 CS*/
        .chat-container::-webkit-scrollbar {
            display: none;
        } 


        /*  내 말풍선 전체 컨테이너     */
        .my-chat-container {
            align-self: flex-end;
            margin-bottom: 0.2rem;
        }


        /* 상대방 말풍선 전체 컨테이너 */
        .your-chat-wrapper {
            align-self: flex-start;
            margin-bottom: 0.2rem;

            display: flex;
            align-items: center;
            margin: var(--chat-container-margin);
        }


        /* 상대방 프로필 이미지 */
        .your-profile-img {
            width: 4rem;
            height: auto;
            border-radius: var(--profile-img-radius);
        }


        /* 아이디 + 대화 텍스트 + 시간 컨테이너         */
        .chat-contents-wrapper {
            margin: var(--chat-contents-wrapper-margin);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }


        /* 상대방 아이디         */
        .your-chat-name {
            color: var(--chat-info-color);
            margin: 0;
            padding: 0.3rem 0rem;
        }


        /* 대화 텍스트 + 시간 컨테이너 */
        .chat-box {
            display: flex;
            flex-basis: var(--chat-box-basis);
        }
        

        /* 상대방 대화 텍스트 */
        .your-chat-msg {
            text-align: left;
            font: var(--chat-font);
            border-radius: var(--chat-radius);
            padding: var(--chat-padding);
            background-color: #fefefe;
        }


        /* 대화 시간 */
        .chat-time {
            color: var(--chat-info-color);
            align-self: flex-end;
            margin: var(--chat-time-margin);
        }


        /* 내 대화 텍스트 */
        .my-chat-msg {
            text-align: right;
            font: var(--chat-font);
            border-radius: var(--chat-radius);
            padding: var(--chat-padding);

            align-self: flex-end;
            background-color: #f9e54d;
            
        }

        /* TODO : 푸터 하단 고정 / header랑 container 높이를 %로 고정하면 되긴 하는데 다이나믹하게 할 수 있는 방법 없나 */
        .speak {
            margin: 0rem 0rem 0rem 0rem;

        }

        /* 푸터 최상위 컨테이너 */
        .speak-container {
            padding: 0.5rem 0rem;
            background-color: #fefefe;
        }

        /* 푸터 텍스트 입력창 + 이모티콘 and 해시태그 아이콘 랩퍼 */
        .speak-contents-wrapper {
            background-color: #f8f8f8;
            border-radius: 1rem;
            padding: 0.2rem 1.2rem;
        }
        
        /* 푸터 텍스트 입력창 */
        .speak textarea {
            background-color: transparent;
            border: none;
            width: 70%;
            height: 1rem;
            overflow-y: hidden; /* 텍스트가 칸을 가득 채워도 옆에 스크롤바 생기지 않도록 만들기 */
            resize: none;   /* textarea 우측 하단 사이즈 조절 버튼 삭제 */
        }

        /* 푸터 사진 추가 + 이모티콘 + 해시태그 아이콘 이미지 */
        .speak img {
            width: 1rem;
            height: auto;
            margin: 0rem 0.3rem;
        }

        
    </style>

    <style type="text/css">
        /* 키보드 css */

        #keyboard {
            border-radius: 1px;
            background-color: #d5d7dd;
            padding: 5px 2px;
            height: 12rem;
            font-family: 'HelveticaNeue-UltraLight', 'Helvetica Neue UltraLight', 'Helvetica Neue', Arial, Helvetica, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: space-between;

        }

        .row {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-content: center;
            margin: 0rem 0.2rem;
        }

        /* 한글/영어일 때 */
        #row2 {
            margin: 0rem 1.5rem 0rem 1.5rem;
        }

        /* 특수문자일 때 */
        #keyboard.is-symbols #row2 {
            margin: 0rem 0.2rem 0rem 0.2rem;
        }
        /* 특수문자일 때 */
        #keyboard.is-symbols #row3 > .key{
            width: 3rem;
        }

        .key {
            background-color: #fefefe;
            -webkit-box-shadow: rgb(106, 106, 106) 0px 1px 1px 0px;
            height: 2.6rem;
            line-height: 2.8rem;
            font-size: 1.2rem;
            border-radius: 7px;
            width: 2.2rem;
            text-align: center;
            font-family: Helvetica;
            color: #000000;
        }

        .systemkey {
            background-color: #b4b8c0;
            color: #000000;
        }

        /* 특수문자일 경우 쉬프트키 */
        #keyboard.is-symbols #ShiftLeft {
            font-size: 0.8rem;
        }

        /* 특수문자일 경우 123키 */
        #keyboard.is-symbols #ToggleKeyboard {
            font-size: 0.8rem;
        }

        .keyPress {
            background-color: #b4b8c0;
        }

        .systemkeyPress {
            color: #000000;
            background-color: #fefefe;
        }
    </style>
    

    <div id="root1">
    </div>











<!--     
    // TODO:
        1) css 정교하게 맞추기
            > 아이템 / 아이콘 크기 맞추기
            > 채팅 입력창 textarea scroll 적용
            > 말풍선 시간이 같을 때만 시간 표시 생략 + 상대방 프사 생략
            > textarea 내용 있을 경우 보내기 버튼으로 바뀜

    // TODO: 
        **1) chat container 높이 맞추기   
            > App 컴포넌트에서 각 하위 컴포넌트들의 높이를 있어야 할 듯. 
            > 속성으로 넣어줄 때는 끝에 'px' 붙이는 거 잊지 않긔
        **2) time 동기화하기
            > header 에 출력되는 device 시간이랑 chat input 되는 시간이랑 동기화하기
            > App 컴포넌트에서 시간을 들고 있고 하위 컴포넌트들에서는 받아다 쓰면 될 듯
        **3) 키보드에 이벤트 마저 걸어주기
            **> 일반키 누르는 효과 CSS 적용하기 : 눌려 있는 키는 해당 컴포넌트가 state 로 들고 있기, 떼면 사라지고.
            **> 특수문자키 키 누르는 CSS 효과 적용하기 : 물음표나 ... 같은 것들, 실제 key 위치랑 다를 경우
            **> shift key 눌렀을 때 이벤트 : 쌍자음 + 특수문자 변경
            **> 특수문자로 전환했을 때 row layout 바뀌는 거 구현 
                +)  컴포넌트가 들고 있는 state에서 key list 내용물을 바꾸기 
                +) 이게 바로 리액트적인 사고. 해당 요소에 접근해서 자리를 저기로 옮기고, 속성을 저렇게 바꾸고, 그게 js적인 사고.
                +) 상황에 따라서 동적으로 변하는 데이터들을 어떻게 컴포넌트 차원에서 들고 있으면서 관리할 수 있을까.

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const h1 = document.querySelector('header').offsetHeight;
            const h2 = document.querySelector('section.keyboard-container').offsetHeight;
            const h3 = document.querySelector('div.container').offsetHeight;
            document.querySelector('section.chat-container').style.height = (h3-h1-h2)+'px';
        })


        // time formatter
        function timeFormatter(param, type) {
            const d = new Date(param);        //파라미터로 전달 받은 날짜를 가지고 새로운 Date 자료형 변수를 만든다.
            const h = d.getHours();     //시를 받아온다.
            const m = d.getMinutes().length < 2 ? '0' + d.getMinutes() : d.getMinutes();   //분을 받아온다
            const n = h < 12 ? '오전' : '오후';      //구분을 받아온다.
            let result = '';
            if(type=='1') {
                result = `${n} ${h}:${m}`;    //JavaScript 새로운 문법 => Template Literals
            } else if (type=='2'){
                result =  `${h}:${m}`;  
            }
            return result;   
        }

        // set the chat time
        const chatTimeEleList = document.querySelectorAll('[name="chatTime"]');
        chatTimeEleList.forEach(function(item, index) {
            const now = new Date();
            const time = timeFormatter(now, 1);
            item.innerText = time;
        });
        
        // set the phone time
        const phoneTimeEleList = document.querySelectorAll('[name="phoneTime"]');
        phoneTimeEleList.forEach(function(item, index) {
            const now = new Date();
            const time = timeFormatter(now, 2);
            item.innerText = time;
        });

        // set event to footer input textarea auto height
        const ta = document.querySelector('textarea');
        ta.addEventListener('input', function() {
            if(ta.scrollHeight > ta.offsetHeight) {
                ta.style.height= ta.scrollHeight + 'px';
            }
        })

    </script> -->

    
    

    <!-- react cdn -->
    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <!-- react dom cdn -->
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- babel cdn -->
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <!-- define type as a babel  -->
    <script type="text/babel">


        // React start

        class App extends React.Component {
            constructor(props) {
                super(props);
                // 원래 이 컴포넌트 안에서만 실행할 때는 bind를 굳이 안 해줘도 되는데, 
                // lifecycle 함수에서 쓸 때는 외부로 넘어가나 보네. componentDidMount 같은 거
                this.setAppTime = this.setAppTime.bind(this);
                this.state = {
                    appTime: new Date().getTime(),
                    chatList: [
                            {isMyChat:1, contents:'당근이세요?', chatTime: '오후 1:21'},
                            {isMyChat:0, contents:'네 안녕하세요', chatTime: '오후 1:23'},
                            {isMyChat:1, contents:'혹시 교통비만 빼주실 수 있을까요 ㅠㅠㅠ', chatTime: '오후 1:25'},
                            {isMyChat:0, contents:'ㅈㅅ....', chatTime: '오후 1:28'},
                        ]
                }

                // 컴포넌트 접근
                this.header = React.createRef();
                this.speak = React.createRef();
                this.outer = React.createRef();

                // 함수 바인딩
                this.setChatList = this.setChatList.bind(this);
            }
            render() {
                return (
                    <div style={{display:"flex", flexDirection:"row", alignItems:"center"}}>
                        <div>
                            <FriendsInput inputHandler={this.setChatList}  appTime={this.state.appTime} />
                        </div>
                        <div className="container" ref={this.outer}>
                            <KakaoHeader appTime={this.state.appTime} ref={this.header} />
                            <KakaoChat chatList={this.state.chatList} chatContainerHeight={this.state.chatContainerHeight} />
                            <KakaoSpeak inputHandler={this.setChatList} appTime={this.state.appTime} ref={this.speak} />
                        </div>
                    </div>
                );
            }

            // 말풍선은 이쪽 컴포넌트 저쪽 컴포넌트 여기저기서 쓰기 때문에 앱 전체에서 들고 있기
            setChatList(isMyChat, contents, chatTime) {   // isMyChat: 내 말풍선인지 친구 말풍선인지 구분자 / contents: 말풍선 내용
                const newItem = {isMyChat: isMyChat, contents: contents, chatTime: chatTime};
                const oldList = this.state.chatList;
                const newList = [...oldList, newItem];
                this.setState({
                    chatList: newList
                });
            }
            
            setChatContainerHeight() {
                // React this 객체에 접근
                // this 
                // this에 header라는 속성 이름으로 저장해 두었던 속성 값에 접근 / 그 안에는 header 컴포넌트를 ref로 할당해 두었음.
                // this.header
                // header 라는 ref의 current 속성에 접근 / 이건 정확히 뭔진 모르겠지만 일단 구조가 그렇게 돼 있었음
                // this.header.current
                // header 라는 ref로 접근하면 이 header 컴포넌트에 접근할 수 있는데, 다시 이 header 컴포넌트는 outer라는 속성 이름으로 어떤 ref를 만들어 두었음. 그리고 이 outer라는 ref 안에는 HTML DOM 요소를 할당해 두었음.
                // this.header.current.outer
                // header 컴포넌트가 outer라는 이름으로 할당해 두었던 ref에 접근해서, 그 안에 있는 HTML DOM 요소에 접근하기 위해 current 속성에 접근. 마찬가지로, 그냥 구조가 그렇게 돼 있길래 이렇게 접근.
                // this.header.current.outer.current
                // 이제 HTML DOM 요소까지 접근했음. DOM 요소가 갖는 속성값들 마음대로 써도 됨.
                // this.header.current.outer.current.tagName / claaList / offsetHeight....
                const h = this.outer.current.clientHeight - this.header.current.outer.current.offsetHeight - this.speak.current.outer.current.offsetHeight;
                this.setState({chatContainerHeight: h})

            }

            // 앱 전체에서 공유할 시간 설정하기
            setAppTime() {
                this.setState({appTime: new Date().getTime()});
            }

            // lifeCycle : 마운트 되기 전에
            componentDidMount() {
                this.setChatContainerHeight();
                // 마운트되면서 시간 설정하고 20초마다 업데이트하기
                this.timerID = setInterval(this.setAppTime,  20000);
            }

            // lifeCycle : 마운트 해제하기 전에
            componentWillUnmount() {
                // 삭제할 때는 인터벌 지워주기
                clearInterval(this.timerID);
            }
        }

        class FriendsInput extends React.Component {
            constructor(props) {
                super(props);
                this.state = {contents: ''}
                this.enterContents = this.enterContents.bind(this);
                this.inputContents = this.inputContents.bind(this);
            }

            inputContents(e) {
                this.setState({contents: e.target.value});
            }
            
            enterContents(e)  {
                // key event 걸기. enter는 submit하고 shif+enter는 다음 줄로 넘어가기
                if(e.code=='Enter') {
                    if(e.shiftKey) {
                        // shift + enter 입력했을 때
                        console.log('next line');
                        // 그러고 보니 지금 textarea라서 엔터 누르면 다음 줄로 넘어가는 건 아무것도 하지 않아도 저절로 그렇게 되네. shift + enter 눌렀을 때 submit 되는 기능만 만들어 두면 될 듯.
                    } else {
                        const t = new Date(this.props.appTime);
                        const time = this.chatTimeFormatter(t);
                        this.props.inputHandler(0, this.state.contents, time);
                        this.setState({contents: ''});
                    }
                }
            }

            // 말풍선 옆에 붙을 시간 형식으로 바꿔주기
            chatTimeFormatter(t) {
                const h = t.getHours() < 13 ? t.getHours() : t.getHours()-12;
                const m = t.getMinutes();
                const n = t.getHours() < 12 ? '오전' : '오후';
                // template literal: "`" 로 감싸고, 그 안에 "${변수명}" 넣으면 변수 값이 그대로 출력
                const time = `${n} ${h}:${m}`;
                // state 로 들고 있으면 이걸 참조하는 말풍선들은 시간이 지날 때마다 함께 업데이트 되고, 결국 모든 말풍선이 같은 시각을 가르키게 됨.
                return time;
            }

            render() {
                return ( <textarea 
                                value={this.state.contents} 
                                onInput={this.inputContents} 
                                onKeyDown={this.enterContents} 
                                style={{boder:"solid black 1px", margin:"0rem 2rem"}} 
                                placeholder="친구 입장에서 메세지 보내기"
                            ></textarea> );
            }

        }

        class KakaoHeader extends React.Component {
            constructor(props) {
                super(props);
                this.state = {
                    unreadChat: 27,
                    chatRoomName: 'Hello My Friend!'
                }

                // outer라는 속성 이름으로 ref를 만들겠다 / 밑에서 이 outer 에 담고 싶은 엘리먼트를 할당해주면 됨.
                this.outer = React.createRef();
            }
            render() {
                return (
                    <header ref={this.outer} >
                        <div className="device-info">
                            <span name="phoneTime">{this.getHeaderTime()}</span>
                            <span>
                                <span><img src="img/signal.png" /></span>
                                <span><img src="img/wifi.png" /></span>
                                <span><img src="img/battery.png" /></span>
                            </span>
                        </div>
                        <div className="chat-info">
                            <span>&lt; {this.state.unreadChat}</span>
                            <span name="yourId">{this.state.chatRoomName}</span>
                            <span>
                                <span><img style={{position: "relative", top:"0.25rem"}} src="img/search.png" /></span>
                                <span><img src="img/hamburger.png" /></span>
                            </span>
                        </div>
                    </header>
                );
            }

            getHeaderTime() {
                const t = new Date(this.props.appTime);
                const h = t.getHours() < 13 ? t.getHours() : t.getHours()-12;
                const m = t.getMinutes() > 9 ? t.getMinutes() : '0' + t.getMinutes();
                // const n = t.getHours() < 12 ? '오전' : '오후';
                // template literal: "`" 로 감싸고, 그 안에 "${변수명}" 넣으면 변수 값이 그대로 출력
                const time = `${h}:${m}`;
                return time;
            }

        }


        class KakaoChat extends React.Component {
            constructor(props) {
                super(props);
                this.state = {
                    friendsName: "내 친구"
                }
                // outer 라는 속성 이름으로 ref를 넣겠다.
                this.outer = React.createRef();
            }

            // lifecycle : 컴포넌트가 업데이트될 때
            componentDidUpdate() {
                // 엘리먼트를 생성할 때 outer라는 이름으로 넣어 두었던 ref를 꺼내오기
                this.outer.current.scrollTop = this.outer.current.scrollHeight

            }
            render() {
                const items = this.props.chatList;
                // 상위 컴포넌트에서 말풍선 목록을 받아와서 내용을 하나씩 꺼내면서 요소를 생성하기
                const renderList = items.map((item, index)=> { 
                    let result; 
                    if(item.isMyChat) {
                        result = (
                            <div className="my-chat-container" key={index}>
                                <span className="chat-contents-wrapper">
                                    <div className="chat-box">
                                        <span className="chat-time" name="chatTime">
                                            {item.chatTime}
                                        </span>
                                        <span className="my-chat-msg">
                                            {item.contents}
                                        </span>
                                    </div>
                                </span>
                            </div>
                        );
                    } else {
                        result = (
                            <div className="your-chat-wrapper" key={index}>
                                <span className="profile-img-wrapper">
                                    <img className="your-profile-img" src="img/default_profile.PNG" alt="default" />
                                </span>
                                <span className="chat-contents-wrapper">
                                    <p className="your-chat-name" name="yourId">{this.state.friendsName}</p>
                                    <div className="chat-box">
                                        <span className="your-chat-msg">
                                            {item.contents}
                                        </span>
                                        <span className="chat-time" name="chatTime">
                                            {item.chatTime}
                                        </span>
                                    </div>
                                </span>
                            </div>
                        );
                    }
                    return result;
                
                });
                return (
                    <section className="chat-container" ref={this.outer} style={{height: this.props.chatContainerHeight}}>
                        {renderList}
                    </section>
                );
            }
        }
        

        class KakaoSpeak extends React.Component {
            constructor(props) {
                super(props);
                
                // 내부에서만 쓰는 함수는 this를 bind해주지 않아도 됨. 실행 주체가 바뀌는 경우에만 bind 해줌
                this.inputContents = this.inputContents.bind(this);
                this.keyDownHandler = this.keyDownHandler.bind(this);
                this.keyUpHandler = this.keyUpHandler.bind(this);

                // outer 라는 속성 이름으로 ref를 만들겠다
                this.outer = React.createRef();

                this.state = {
                    contents: '',
                    keyboardSettings: {korean: 'is-korean', english:'is-english', symbols:'is-symbols'},
                    keyboardToggle: {korean: "ArrowRight", symbols:"End", english: "ArrowDown"},
                    keyboardType: 'is-korean',
                    isShift: false,
                    pressedKeys: [],
                    keyList: { 
                        row1: [
                            {code: 'KeyQ', Korean: 'ㅂ', English: 'q', Symbols: '1', Shift: 'ㅃ'},
                            {code: 'KeyW', Korean: 'ㅈ', English: 'w', Symbols: '2', Shift: 'ㅉ'},
                            {code: 'KeyE', Korean: 'ㄷ', English: 'e', Symbols: '3', Shift: 'ㄸ'},
                            {code: 'KeyR', Korean: 'ㄱ', English: 'r', Symbols: '4', Shift: 'ㄲ'},
                            {code: 'KeyT', Korean: 'ㅅ', English: 't', Symbols: '5', Shift: 'ㅆ'},
                            {code: 'KeyY', Korean: 'ㅛ', English: 'y', Symbols: '6'},
                            {code: 'KeyU', Korean: 'ㅕ', English: 'u', Symbols: '7'},
                            {code: 'KeyI', Korean: 'ㅑ', English: 'i', Symbols: '8'},
                            {code: 'KeyO', Korean: 'ㅐ', English: 'o', Symbols: '9', Shift: 'ㅒ'},
                            {code: 'KeyP', Korean: 'ㅔ', English: 'p', Symbols: '0', Shift: 'ㅖ'},
                        ],
                        row2: [
                            {code: 'KeyA', Korean: 'ㅁ', English: 'a', Symbols: '-'},
                            {code: 'KeyS', Korean: 'ㄴ', English: 's', Symbols: '/'},
                            {code: 'KeyD', Korean: 'ㅇ', English: 'd', Symbols: ':'},
                            {code: 'KeyF', Korean: 'ㄹ', English: 'f', Symbols: ';'},
                            {code: 'KeyG', Korean: 'ㅎ', English: 'g', Symbols: '('},
                            {code: 'KeyH', Korean: 'ㅗ', English: 'h', Symbols: ')'},
                            {code: 'KeyJ', Korean: 'ㅓ', English: 'j', Symbols: '\\'},
                            {code: 'KeyK', Korean: 'ㅏ', English: 'k', Symbols: '&'},
                            {code: 'KeyL', Korean: 'ㅣ', English: 'l', Symbols: '@'},
                        ],
                        row3: [
                            {code: 'KeyZ', Korean: 'ㅋ', English: 'z', Symbols: '\"'},
                            {code: 'KeyX', Korean: 'ㅌ', English: 'x', Symbols: '.'},
                            {code: 'KeyC', Korean: 'ㅊ', English: 'c', Symbols: ','},
                            {code: 'KeyV', Korean: 'ㅍ', English: 'v', Symbols: '?'},
                            {code: 'KeyB', Korean: 'ㅠ', English: 'b', Symbols: '!'},
                            {code: 'KeyN', Korean: 'ㅜ', English: 'n', Symbols: '\''},
                            {code: 'KeyM', Korean: 'ㅡ', English: 'm', Symbols: ''}
                        ]
                    }
                };

            }

            render() {
                // 키보드 안에 들어갈 키 내용물들 요소 만들기
                const keyboardRow1 = this.getKeyboardRow(this.state.keyList.row1);
                const keyboardRow2 = this.getKeyboardRow(this.state.keyList.row2);
                const keyboardRow3 = this.getKeyboardRow(this.state.keyList.row3);

                return (
                    <div ref={this.outer} >

                        <section className="speak">
                            <div className="speak-container">
                                <span><img src="img/plus.png" alt="plus" /></span>
                                <span className="speak-contents-wrapper">
                                    <span><textarea type="text" 
                                                    value={this.state.contents} 
                                                    onInput={this.inputContents} 
                                                    onKeyDown={this.keyDownHandler}
                                                    onKeyUp={this.keyUpHandler}
                                                ></textarea></span>
                                    <span><img src="img/emoji.png" alt="emoji" /></span>
                                    <span><img src="img/hashtag.png" alt="hashtag" /></span>
                                </span>
                            </div>
                        </section>
                        
                        <section className="keyboard-container">
                            <div id="keyboard" className={this.state.keyboardType}>
                                <div className="row" id="row1">
                                    {keyboardRow1}
                                </div>
                                <div className="row" id="row2">
                                    {keyboardRow2}
                                </div>
                                <div className="row" id="row3">
                                    <div id="ShiftLeft" className={this.getKeyClassName(true, 'ShiftLeft')} style={{width: "2.5rem", margin: "0rem 0.5rem 0rem 0rem"}}>{this.state.keyboardType==this.state.keyboardSettings.symbols ? "#+=" : "⌂"}</div>
                                    {keyboardRow3}
                                    <div id="Backspace" className={this.getKeyClassName(true, 'Backspace')} style={{width: "2.5rem",  margin: "0rem 0rem 0rem 0.5rem"}}>⌫</div>
                                </div>
                                <div className="row" id="row4">
                                    <div id="ToggleKeyboard" className={this.getKeyClassName(true)} style={{width: "2.5rem"}}>{this.state.keyboardType==this.state.keyboardSettings.symbols ? "한글" : "123"}</div>
                                    <div className={this.getKeyClassName(true)} style={{width: "2.5rem"}}>☺️</div>
                                    <div id="Space" className={this.getKeyClassName(false, 'Space')} style={{width: "12.5rem", fontSize: "1rem", fontWeight: "400"}}>간격</div>
                                    <div className={this.getKeyClassName(true)} style={{width: "5.5rem"}}>⏎</div>
                                </div>
                            </div>
                        </section>

                    </div>
                );
            }

            // textarea <=> state 값 동기화
            inputContents(e) {
                this.setState({
                    contents: e.target.value
                });
                // 입력하는 내용이 textarea 입력창을 넘어간 상태라면 스크롤창을 가장 아래로 내리기
                e.target.scrollTop = e.target.scrollHeight;
            }

            // list 주면 keyboard에서 row 하나를 만들어서 되돌려줌. 한글 or 영어 or 특수문자 출력값도 넣어 주고 className 이나 wrapper 까지 알아서 고려함.
            getKeyboardRow(keyList) {
                const result = keyList.map((item, index)=>{
                        return ( <div id={item.code} className={this.getKeyClassName(false, item.code)} key={item.code} >{this.getKeyTextVal(item)}</div> );
                    });

                return result;
            }

            // keyboard에서 key 요소들 만들 때 className 만들어서 되돌려주기
            getKeyClassName(isSystemKey,code) {
                const cl = ['key'];
                
                // 시스템키일 경우 systemkey 클래스 추가
                if(isSystemKey) {
                    cl.push('systemkey');
                }

                // 눌려 있는 키들 css 적용 클래스 추가
                if(this.state.pressedKeys.includes(code)) {
                    if(isSystemKey) {
                        cl.push('systemkeyPress');
                    } else {
                        cl.push('keyPress');
                    }
                }

                return cl.join(" ");
            }

            // type 에 따라서 한글/영어/특수문자 되돌려주기
            getKeyTextVal(item) {
                let result;
                if(this.state.isShift && this.state.keyboardType == this.state.keyboardSettings.korean) {   // 한글이면서 shift 누르면
                    result = item.Shift || item.Korean;
                } else if(this.state.keyboardType == this.state.keyboardSettings.korean) {     // 그냥 한글이면
                    result = item.Korean;
                } else if(this.state.keyboardType == this.state.keyboardSettings.symbols) {     // 특수문자면
                    result = item.Symbols;
                } else if(this.state.keyboardType == this.state.keyboardSettings.english) {     // 영어면
                    result = item.English;
                } else {
                    console.log('uncaught keyboard type');
                    result = 'error';
                }
                return result;
            }

            // 말풍선 옆에 붙을 시간 형식으로 바꿔주기
            chatTimeFormatter(t) {
                const h = t.getHours() < 13 ? t.getHours() : t.getHours()-12;
                const m = t.getMinutes();
                const n = t.getHours() < 12 ? '오전' : '오후';
                // template literal: "`" 로 감싸고, 그 안에 "${변수명}" 넣으면 변수 값이 그대로 출력
                const time = `${n} ${h}:${m}`;
                // state 로 들고 있으면 이걸 참조하는 말풍선들은 시간이 지날 때마다 함께 업데이트 되고, 결국 모든 말풍선이 같은 시각을 가르키게 됨.
                return time;
            }

                // |\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/| 키보드 이벤트 |\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|
            // 키보드 누름 이벤트
            keyDownHandler(e) {
                // keyboard press event handler
                this.keyboardKeyDownHandler(e);
            }
            
            // 키보드 뗌 이벤트
            keyUpHandler(e) {
                this.keyboardKeyUpHandler(e);
            }
            // =================== keyboard event start ======================
            keyboardKeyDownHandler(e) {
                console.log(e);
                this.effectKeyDown(e.code);  // 키 누르면 css 변경
                this.changeKeyboardType(e.code);   // 문자나 레이아웃 변경
                this.effectSymbolKeyDown(e);  // 시스템키들 개별 이벤트
                this.effectShiftKeyDown(e); // 한글 쌍자음 이벤트 - shift 누를 때
                this.submitContent(e);  // 엔터키 이벤트

            }

            // enter는 상위 컴포넌트로 submit하고 shif+enter는 다음 줄로 넘어가기
            submitContent(e) {
                if(e.code=='Enter') {
                    if(e.shiftKey) {
                        // shift + enter 입력했을 때
                        console.log('next line');
                        // 그러고 보니 지금 textarea라서 엔터 누르면 다음 줄로 넘어가는 건 아무것도 하지 않아도 저절로 그렇게 되네. shift + enter 눌렀을 때 submit 되는 기능만 만들어 두면 될 듯.
                    } else {
                        // props 를 그대로 참조하면 그 props를 넣어주는 상위 컴포넌트에서 state가 바뀔 때마다 그 값을 참조하고 있는 다른 요소들도 값이 함께 바뀌게 됨.
                        // 즉 모든 말풍선이 같은 시각을 가르키게 됨.
                        // 따라서 Date 객체가 state와는 별개의 객체로 존재해야 함.
                        // 따라서 app에서 들고 있는 state 는 UTC 타임만 들고 있고, 다른 데에서 사용할 때는 그 UTC를 파라미터로 넣은 새로운 Date 객체를 매번 따로 만들어서 사용하기.
                        const t = new Date(this.props.appTime);
                        const time = this.chatTimeFormatter(t);
                        this.props.inputHandler(1, this.state.contents, time);
                        this.setState({contents: ''});
                    }
                }
            }


            // 키 뗄 때 이벤트
            keyboardKeyUpHandler(e) {
                this.effectKeyUp(e.code);
                this.effectShiftKeyUp(e);
                this.effectSymbolKeyUp(e);
            }

            // 키 뗄 때 css 적용 (class로 css 관리)
            effectKeyUp(code) {
                const oldList = this.state.pressedKeys;
                const newList = oldList.filter((item)=>{ 
                                    if(item == code) {return false;} 
                                    else {return true;}
                                });
                this.setState({pressedKeys: newList});
            }

            
            // 키 누를 때 css 적용 (class로 css 관리)
            effectKeyDown(code) {
                const oldList = this.state.pressedKeys;
                const newList = [...oldList, code];
                this.setState({pressedKeys: newList});

            }

            // 키보드 한글/영어/특수문자 전환
            changeKeyboardType(code) {
                const isToggle = (code == this.state.keyboardToggle.korean || 
                            code == this.state.keyboardToggle.english  || 
                            code == this.state.keyboardToggle.symbols  );
                if(isToggle) {
                    if(this.state.keyboardType == this.state.keyboardSettings.symbols) {
                        // keyboardType이 이미 특수문자일 경우 키보드 레이아웃 원래대로 되돌리기
                        this.toggleSymbolsLayout(true);
                    }
                } else {
                    // 누른 키가 한영 변환이나 특수문자 변환이 아니면 그대로 끝내기
                    return;
                }
                
                // toggle 키에 따라서 keyboard type 바꿔주기
                if(code == this.state.keyboardToggle.korean) {
                    this.setState({keyboardType: this.state.keyboardSettings.korean});
                } else if(code == this.state.keyboardToggle.english) {
                    this.setState({keyboardType: this.state.keyboardSettings.english});
                } else if(code == this.state.keyboardToggle.symbols) {
                    this.setState({keyboardType: this.state.keyboardSettings.symbols});
                    // keyboardType을 특수문자로 바꿀 경우 KeyZ 를 row2로 옮기기
                    this.toggleSymbolsLayout(false);
                }
                
            }

            // 키보드가 특수문자일 경우 레이아웃이 바뀜.
            toggleSymbolsLayout(flag) {
                // keyList 전체 복사해 오기 spread syntax 배열이랑 객체 둘 다 가능. [...arr] / {...obj} 
                const kl = {...this.state.keyList};
                if(flag) {  // keyboardType이 특수문자일 경우 키보드 레이아웃 원래대로 되돌리기
                    // row2에서 마지막 요소 꺼내기
                    const keyZ = kl.row2.pop();
                    // 배열 row3 에서 0번째 인덱스부터 0개 요소를 제거한 뒤에 그 자리에 keyZ를 넣기
                    kl.row3.splice(0, 0, keyZ);
                    // 배열 row3에 요소 하나 추가
                    kl.row3.push({code: 'KeyM', Korean: 'ㅡ', English: 'm', Symbols: ''});
                    
                } else {    // keyboardType을 특수문자로 바꿀 경우 KeyZ 를 row2로 옮기기
                    // 배열에서 첫 요소 제거 + 반환 (mutating original array)
                    const relocatingKey = kl.row3.shift();
                    // 배열에서 마지막 요소 제거 + 반환 (mutating original array)
                    kl.row3.pop();
                    // 꺼낸 요소 넣기
                    kl.row2.push(relocatingKey);
                }
                this.setState({keyList:kl});
            }

            // 특수문자 css 개별 이벤트
            effectSymbolKeyDown(e) {
                // 키보드가 특수문자일 경우 경우에만 작동
                if(!this.state.keyboardType == this.state.keyboardSettings.symbols) {
                    return;
                }

                const key = this.getSymbolKeyMapping(e);
                
                if(key) {
                    this.effectKeyDown(key);
                }
                return;

            }

            // 특수문자 css 개별 이벤트
            effectSymbolKeyUp(e) {
                // 키보드가 특수문자일 경우 경우에만 작동
                if(!this.state.keyboardType == this.state.keyboardSettings.symbols) {
                    return;
                }

                const key = this.getSymbolKeyMapping(e);
                
                if(key) {
                    this.effectKeyUp(key);
                }
                return;

            }

            // 코드는 넣어주면 해당 특수문자키가 어떤 일반키랑 맵핑인지 뱉어줌
            getSymbolKeyMapping(e) {
                let key = "";

                // shift 눌러야 하는 특수문자들
                if(e.shiftKey) {
                    // ??? 물음표 이벤트
                    if(e.code == 'Slash') {
                        key = "KeyV";
                    }
                    // !!! 느낌표 이벤트
                    if(e.code == 'Digit1') { 
                        key = "KeyB";
                    }
                    // """ 쌍따옴표 이벤트
                    if(e.code == 'Quote') {
                        key = "KeyZ";
                    }
                } else {
                    // ... 쩜쩜쩜 이벤트
                    if(e.code == 'Period') {
                        key = "KeyX";
                    }
                    // ,,, 쉼표 이벤트
                    if(e.code == 'Comma') {
                        key = "KeyC";
                    }
                    // ''' 따옴표 이벤트
                    if(e.code == 'Quote') {
                        key = "KeyN";
                    }
                }
                return key;
            }
            // 쌍자음 효과 - shift key 누를 때
            effectShiftKeyDown(e) {
                if(e.code == 'ShiftLeft') { // 왼쪽 shift키 이벤트
                    this.setState({isShift: true});
                    setTimeout(console.log('dd'), 1000);
                }

                
            }

            // 쌍자음 효과 - shift key 뗄 때
            effectShiftKeyUp(e) {
                if(e.code == 'ShiftLeft') { // 왼쪽 shift키 이벤트
                    this.setState({isShift: false});
                }

            }

        }
// end of speak section !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        ReactDOM.render(<App />, document.querySelector('#root1'));

    </script>
</body>
</html>