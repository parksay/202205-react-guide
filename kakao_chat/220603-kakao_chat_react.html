<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <style>
        /* 카카오 채팅창 css */

        :root { 
            font-size: 12px;
            /* 아이디 + 대화 텍스트 + 시간 컨테이너 마진        */
            --chat-contents-wrapper-margin: 0rem 0.6rem;
            /* 대화 텍스트 + 시간 컨테이너 높이 */
            --chat-box-basis: 2.5rem;
            /* 대화 시간 + 상대방 아이디 텍스트 컬러 */
            --chat-info-color: #555c62;
            /* 대화 시간 마진 */
            --chat-time-margin: 0rem 0.3rem;
            /* 대화 텍스트 패딩 */
            --chat-padding: 0.6rem 0.6rem;
            /* 대화 텍스트 굴곡 */
            --chat-radius: 15px;
            /* 대화 텍스트 스타일 */
            --chat-font: 1.2rem "Fira Sans", sans-serif;
        }


        body {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;

        }

        
        /*  카톡창 전체     */
        .container {    
            width: 400px;
            height: 800px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background-color: #afc0cf;

            /* remove later */
            border: 1px solid red;

        }

        /* 상단 스마트폰 상태창 + 상단 카톡방 정보창 */
        header > div {
            font-weight: bold;

            display: flex;
            padding: 0.5rem 0rem;
            justify-content: space-between;
        }

        /* 스마트폰 정보 아이콘 + 카톡방 검색 and 햄버거 메뉴 아이콘 */
        header img {
            width: 1.5rem;
            height: auto;
            
        }

        /* 상단 스마트폰 상태창 */
        .device-info {
            align-items: center;
            margin: 0rem 2rem;
            font-size: 1.3rem;
            font-weight: 800;
        }

        /* 상단 스마트폰 상태창 아이콘 */
        .device-info img {
            margin: 0rem 0.2rem;
        }

        /* 상단 카톡방 정보창 */
        .chat-info {
            margin: 0rem 1rem;
            align-items: center;
            font-size: 1.3rem;
            font-weight: 800;
        }

        /* 상단 카톡방 정보창 아이콘 이미지 랩퍼 */
        .chat-info > span > span {
            margin: 0rem 0.4rem;
        }


        /* 카톡방 대화창 전체 */
        .chat-container {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;    /* 말풍선 위쪽부터 하나씩 채우기 */
            overflow-y: scroll; /*  말풍선이 많아져서 컨테이너를 넘쳤을 경우 스크롤해서 보여주기 */
        }

        /* 카톡방 대화창 전체 스크롤바 CS*/
        .chat-container::-webkit-scrollbar {
            display: none;
        } 


        /*  내 말풍선 전체 컨테이너     */
        .my-chat-container {
            align-self: flex-end;
            margin-bottom: 0.2rem;
            margin: 0.0rem 0.0rem 0.5rem 0.0rem;
        }


        /* 상대방 말풍선 전체 컨테이너 */
        .your-chat-wrapper {
            align-self: flex-start;
            display: flex;
            align-items: center;
        }

        /* 상대방 첫 번째 말풍선이 아니라면 상대방 프로필 이미지만큼 마진 */
        .your-chat-wrapper.first-chat {
            margin: 0rem 0rem 0.5rem 0.6rem;
        }
        .your-chat-wrapper {
            /* 왼쪽 마진 : 상대방 프로필 사진 너비 + first-chat 왼쪽 마진 */
            margin: 0rem 0rem 0.5rem 3.6rem;
        }
        /* 상대방 말풍선 묶음들 안에서 첫 번째 말풍선이 아니라면 프로필 사진과 친구 이름 숨기기*/
        .your-chat-wrapper span.profile-img-wrapper {
            display:none;
        }
        .your-chat-wrapper p.your-chat-name  {
            display:none;
        }
        .your-chat-wrapper.first-chat span.profile-img-wrapper {
            display:inline;
        }
        .your-chat-wrapper.first-chat p.your-chat-name  {
            display:inline;
        }


        /* 상대방 프로필 이미지 */
        .your-profile-img {
            width: 3rem;
            height: auto;
            border-radius: 1.2rem;
        }


        /* 아이디 + 대화 텍스트 + 시간 컨테이너         */
        .chat-contents-wrapper {
            margin: var(--chat-contents-wrapper-margin);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }


        /* 상대방 아이디         */
        .your-chat-name {
            color: var(--chat-info-color);
            margin: 0;
            padding: 0.3rem 0rem;
        }


        /* 대화 텍스트 + 시간 컨테이너 */
        .chat-box {
            display: flex;
            flex-basis: var(--chat-box-basis);
        }
        

        /* 상대방 대화 텍스트 */
        .your-chat-msg {
            text-align: left;
            font: var(--chat-font);
            border-radius: var(--chat-radius);
            padding: var(--chat-padding);
            background-color: #fefefe;
        }


        /* 대화 시간 */
        .chat-time {
            color: var(--chat-info-color);
            align-self: flex-end;
            margin: var(--chat-time-margin);
            display:none;
        }

        /* 말풍선 묶음들 중에 가장 마지막에 있는 말풍선만 시간 보여주기 */
        .chat-time.last-chat {
            display:inline;
        }

        /* 내 대화 텍스트 */
        .my-chat-msg {
            text-align: right;
            font: var(--chat-font);
            border-radius: var(--chat-radius);
            padding: var(--chat-padding);

            align-self: flex-end;
            background-color: #f9e54d;
            
        }

        .speak {
            margin: 0rem 0rem 0rem 0rem;
        }

        /* 푸터 최상위 컨테이너 */
        .speak-container {
            padding: 0.5rem 0rem;
            background-color: #fefefe;
        }

        /* 푸터 텍스트 입력창 + 이모티콘 and 해시태그 아이콘 랩퍼 */
        .speak-contents-wrapper {
            background-color: #f8f8f8;
            border-radius: 1rem;
            padding: 0.2rem 1.2rem;
        }
        
        /* 푸터 텍스트 입력창 */
        .speak textarea {
            background-color: transparent;
            border: none;
            width: 72%;
            overflow-y: scroll; 
            resize: none;   /* textarea 우측 하단 사이즈 조절 버튼 삭제 */
            outline: none;  /* textarea에 내용을 입력하는 동안, 즉 focus 된 동안 강조 테두리 제거 */
            caret-color: rgb(36, 90, 238); /* textarea에 내용을 입력하는 동안 깜빡이는 text 커서 색상 바꾸기 */
            
        }

        /* 푸터 텍스트 입력창 */
        .speak textarea::-webkit-scrollbar {
            /* 텍스트가 칸을 가득 채워도 옆에 스크롤바 생기지 않도록 만들기 */
            display: none;
        }  

        /* 푸터 사진 추가 + 이모티콘 + 해시태그 아이콘 이미지 */
        .speak img {
            width: 1.5rem;
            height: auto;
            margin: 0rem 0.3rem;
        }

        
    </style>

    <style type="text/css">
        /* 키보드 css */

        #keyboard {
            border-radius: 1px;
            background-color: #d5d7dd;
            padding: 5px 2px;
            height: 16rem;
            font-family: 'HelveticaNeue-UltraLight', 'Helvetica Neue UltraLight', 'Helvetica Neue', Arial, Helvetica, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: space-between;

        }

        .row {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-content: center;
            margin: 0% 1%;
        }

        /* 한글/영어일 때 */
        #row2 {
            margin: 0 5%;
        }
        #row2 > .key {
            width: 9.7%;
        }

        /* 특수문자일 때 */
        #keyboard.is-symbols #row2 {
            margin: 0rem 0.3rem;
        }
        /* 특수문자일 때 */
        #keyboard.is-symbols #row3 > .key{
            width: 4rem;
        }

        .key {
            background-color: #fefefe;
            -webkit-box-shadow: rgb(106, 106, 106) 0px 1px 1px 0px;
            height: 100%;
            line-height: 3.3rem;
            font-size: 1.5rem;
            font-weight: 540;
            border-radius: 7px;
            width: 9%;
            text-align: center;
            font-family: Helvetica;
            color: #000000;
        }

        .systemkey {
            background-color: #b4b8c0;
            color: #000000;
        }

        /* 특수문자일 경우 쉬프트키 */
        #keyboard.is-symbols #ShiftLeft {
            font-size: 0.8rem;
        }

        /* 특수문자일 경우 123키 */
        #keyboard.is-symbols #ToggleKeyboard {
            font-size: 0.8rem;
        }

        .keyPress {
            background-color: #b4b8c0;
        }

        .systemkeyPress {
            color: #000000;
            background-color: #fefefe;
        }
    </style>
    

    <div id="root1">
    </div>











<!--     
    // TODO:
        1) css 정교하게 맞추기
            > 말풍선 max width 맞추기
            > 키보드 시스템키 문자 맞추기 폰트 없으면 사진으로
        2) textarea 내용 있을 경우 보내기 버튼으로 바뀜
        3) textarea 높이

    -->

    
    

    <!-- react cdn -->
    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <!-- react dom cdn -->
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- babel cdn -->
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <!-- define type as a babel  -->
    <script type="text/babel">


        // React start

        class App extends React.Component {
            constructor(props) {
                super(props);
                // 원래 이 컴포넌트 안에서만 실행할 때는 bind를 굳이 안 해줘도 되는데, 
                // lifecycle 함수에서 쓸 때는 외부로 넘어가나 보네. componentDidMount 같은 거
                this.setAppTime = this.setAppTime.bind(this);
                this.state = {
                    appTime: new Date().getTime(),
                    chatList: [
                            {isMyChat:1, contents:'당근이세요?', chatTime: '오후 1:21', isFirstChat: true, isLastChat: true},
                            {isMyChat:0, contents:'네 안녕하세요', chatTime: '오후 1:23', isFirstChat: true, isLastChat: true},
                            {isMyChat:1, contents:'혹시 교통비만 빼주실 수 있을까요 ㅠㅠㅠ', chatTime: '오후 1:25', isFirstChat: true, isLastChat: true},
                            {isMyChat:0, contents:'ㅈㅅ....', chatTime: '오후 1:28', isFirstChat: true, isLastChat: true},
                        ]
                }

                // 컴포넌트 접근
                this.header = React.createRef();
                this.speak = React.createRef();
                this.chat = React.createRef();
                this.outer = React.createRef();

                // 함수 바인딩
                this.setChatList = this.setChatList.bind(this);
            }
            render() {
                return (
                    <div style={{display:"flex", flexDirection:"row", alignItems:"center"}}>
                        <div>
                            <FriendsInput inputHandler={this.setChatList}  appTime={this.state.appTime} />
                        </div>
                        <div className="container" ref={this.outer}>
                            <KakaoHeader appTime={this.state.appTime} ref={this.header} />
                            <KakaoChat chatList={this.state.chatList} chatContainerHeight={this.state.chatContainerHeight} ref={this.chat} />
                            <KakaoSpeak inputHandler={this.setChatList} appTime={this.state.appTime} ref={this.speak} />
                        </div>
                    </div>
                );
            }

            // 말풍선은 이쪽 컴포넌트 저쪽 컴포넌트 여기저기서 쓰기 때문에 앱 전체에서 들고 있기
            setChatList(isMyChat, contents, chatTime) {   // isMyChat: 내 말풍선인지 친구 말풍선인지 구분자 / contents: 말풍선 내용 / chatTime: 말풍선 입력할 때 시간
                const oldList = this.state.chatList;
                // 여기서 oldList를 수정하게 되면 state 를 직접 수정하게 됨. state를 직접 수정하면 렌더링을 유발하지 못함. setState를 사용해서 변경해야만 렌더링을 다시 하게 됨. 따라서 state에서 특정 값을 복사해와서 새로운 객체를 만든 뒤 그 객체를 수정함.
                // spread syntax는 새 객체를 만드는 문법이 아니라 주소값만 복사해옴. array 중에 원본을 mutation 하지 않고 별개의 배열을 return 값으로 돌려주는 함수 찾기
                // const newList = [...oldList, newItem];
                const newList = oldList.concat();
                // 친구 말풍선만 or 내 말풍선만 받아오기 => 마지막 말풍선 접근하려고
                let tempChatList;
                if(isMyChat) {
                    tempChatList = newList.filter(function(item, index, arr) {
                        if(item.isMyChat) return item;
                    });
                } else {
                    tempChatList = newList.filter(function(item, index, arr) {
                        if(!item.isMyChat) return item;
                    });
                }
                // 말풍선 중에 마지막 말풍선에 접근
                const lastItem = tempChatList[tempChatList.length - 1];
                // 친구 말풍선에서 묶음 중에 첫 말풍선인지. 지금은 내 말풍선에서는 이 속성을 쓰고 있지 않기 때문에 분기문 처리를 안 했지만, 내 말풍선에서도 쓰는 속성이라면 분기문 처리까지 해야 할 듯.
                let isFirstChat = true;
                // 나중에 새로 추가할 말풍선에 넣어줄 isLastChat 값.
                let isLastChat = true;
                // 마지막 말풍선 입력 시간 받아오기
                let lasChatTime;
                if(isMyChat) {
                    lasChatTime = this.chat.current.state.myLastChatTime;
                } else {
                    lasChatTime = this.chat.current.state.yourLastChatTime;
                }

                if(contents == 'a' ) debugger;
                // 일단 기본값은 내가 가장 마지막 말풍선이니까 내 isLastChat는 true로 가져가고, 만약에 이러이러한 조건이 맞다면 바로 이전 말풍선에서 시간만 지워주면 되지.
                if(oldList[oldList.length-1].isMyChat == isMyChat) { // 내가 말했으면 내 말풍선이, 친구가 말했으면 친구 말풍선이 그대로 이어지면서,
                    if(lasChatTime == chatTime) {   // 말풍선 입력한 시간도 마지막 말풍선과 같은 시각일 경우에만
                        // 기존 마지막 말풍선에서는 시간을 지우기
                        lastItem.isLastChat = false;
                        // 친구 말풍선에서는 프로필사진과 친구 아이디 지우기
                        isFirstChat = false;
                    } 
                } 

                // isLastChat 값이 true든 false든 상관 없이 계속 갱신해 주면 됨. 어차피 같으면 같은 값으로 들어갈 거고, 다르면 다른 값이 들어갈 거니까.
                if(isMyChat) {
                    this.chat.current.setState({myLastChatTime: chatTime});
                } else {
                    this.chat.current.setState({yourLastChatTime: chatTime});
                }

                const newItem = {isMyChat: isMyChat, contents: contents, chatTime: chatTime, isLastChat: isLastChat, isFirstChat: isFirstChat};
                newList.push(newItem);
                this.setState({
                    chatList: newList
                });
            }
            
            setChatContainerHeight() {
                // React this 객체에 접근
                // this 
                // this에 header라는 속성 이름으로 저장해 두었던 속성 값에 접근 / 그 안에는 header 컴포넌트를 ref로 할당해 두었음.
                // this.header
                // header 라는 ref의 current 속성에 접근 / 이건 정확히 뭔진 모르겠지만 일단 구조가 그렇게 돼 있었음
                // this.header.current
                // header 라는 ref로 접근하면 이 header 컴포넌트에 접근할 수 있는데, 다시 이 header 컴포넌트는 outer라는 속성 이름으로 어떤 ref를 만들어 두었음. 그리고 이 outer라는 ref 안에는 HTML DOM 요소를 할당해 두었음.
                // this.header.current.outer
                // header 컴포넌트가 outer라는 이름으로 할당해 두었던 ref에 접근해서, 그 안에 있는 HTML DOM 요소에 접근하기 위해 current 속성에 접근. 마찬가지로, 그냥 구조가 그렇게 돼 있길래 이렇게 접근.
                // this.header.current.outer.current
                // 이제 HTML DOM 요소까지 접근했음. DOM 요소가 갖는 속성값들 마음대로 써도 됨.
                // this.header.current.outer.current.tagName / claaList / offsetHeight....
                const h = this.outer.current.clientHeight - this.header.current.outer.current.offsetHeight - this.speak.current.outer.current.offsetHeight;
                this.setState({chatContainerHeight: h})

            }

            // 앱 전체에서 공유할 시간 설정하기
            setAppTime() {
                this.setState({appTime: new Date().getTime()});
            }

            // lifeCycle : 마운트 되기 전에
            componentDidMount() {
                this.setChatContainerHeight();
                // 마운트되면서 시간 설정하고 20초마다 업데이트하기
                this.timerID = setInterval(this.setAppTime,  20000);
            }

            // lifeCycle : 마운트 해제하기 전에
            componentWillUnmount() {
                // 삭제할 때는 인터벌 지워주기
                clearInterval(this.timerID);
            }
        }

        class FriendsInput extends React.Component {
            constructor(props) {
                super(props);
                this.state = {contents: ''}
                this.enterContents = this.enterContents.bind(this);
                this.inputContents = this.inputContents.bind(this);
            }

            inputContents(e) {
                this.setState({contents: e.target.value});
            }
            
            enterContents(e)  {
                // key event 걸기. enter는 submit하고 shif+enter는 다음 줄로 넘어가기
                if(e.code=='Enter') {
                    if(e.shiftKey) {
                        // shift + enter 입력했을 때
                        console.log('next line');
                        // 그러고 보니 지금 textarea라서 엔터 누르면 다음 줄로 넘어가는 건 아무것도 하지 않아도 저절로 그렇게 되네. shift + enter 눌렀을 때 submit 되는 기능만 만들어 두면 될 듯.
                    } else {
                        const t = new Date(this.props.appTime);
                        const time = this.chatTimeFormatter(t);
                        this.props.inputHandler(0, this.state.contents, time);
                        this.setState({contents: ''});
                    }
                }
            }

            // 말풍선 옆에 붙을 시간 형식으로 바꿔주기
            chatTimeFormatter(t) {
                const h = t.getHours() < 13 ? t.getHours() : t.getHours()-12;
                const m = t.getMinutes() > 9 ? t.getMinutes() : '0' + t.getMinutes();
                const n = t.getHours() < 12 ? '오전' : '오후';
                // template literal: "`" 로 감싸고, 그 안에 "${변수명}" 넣으면 변수 값이 그대로 출력
                const time = `${n} ${h}:${m}`;
                // state 로 들고 있으면 이걸 참조하는 말풍선들은 시간이 지날 때마다 함께 업데이트 되고, 결국 모든 말풍선이 같은 시각을 가르키게 됨.
                return time;
            }

            render() {
                return ( <textarea 
                                value={this.state.contents} 
                                onInput={this.inputContents} 
                                onKeyDown={this.enterContents} 
                                style={{boder:"solid black 1px", margin:"0rem 2rem"}} 
                                placeholder="친구 입장에서 메세지 보내기"
                            ></textarea> );
            }

        }

        class KakaoHeader extends React.Component {
            constructor(props) {
                super(props);
                this.state = {
                    unreadChat: 27,
                    chatRoomName: 'Hello My Friend!'
                }

                // outer라는 속성 이름으로 ref를 만들겠다 / 밑에서 이 outer 에 담고 싶은 엘리먼트를 할당해주면 됨.
                this.outer = React.createRef();
            }
            render() {
                return (
                    <header ref={this.outer} >
                        <div className="device-info">
                            <span name="phoneTime">{this.getHeaderTime()}</span>
                            <span>
                                <span><img src="img/signal.png" /></span>
                                <span><img src="img/wifi.png" /></span>
                                <span><img src="img/battery.png" style={{position:'relative', top:'1px'}}/></span>
                            </span>
                        </div>
                        <div className="chat-info">
                            <span>&lt; {this.state.unreadChat}</span>
                            <span name="yourId">{this.state.chatRoomName}</span>
                            <span>
                                <span><img style={{position: "relative", top:"0.25rem"}} src="img/search.png" /></span>
                                <span><img src="img/hamburger.png" /></span>
                            </span>
                        </div>
                    </header>
                );
            }

            getHeaderTime() {
                const t = new Date(this.props.appTime);
                const h = t.getHours() < 13 ? t.getHours() : t.getHours()-12;
                const m = t.getMinutes() > 9 ? t.getMinutes() : '0' + t.getMinutes();
                // const n = t.getHours() < 12 ? '오전' : '오후';
                // template literal: "`" 로 감싸고, 그 안에 "${변수명}" 넣으면 변수 값이 그대로 출력
                const time = `${h}:${m}`;
                return time;
            }

        }


        class KakaoChat extends React.Component {
            constructor(props) {
                super(props);
                this.state = {
                    myLastChatTime: '',
                    yourLastChatTime: '',
                    friendsName: "내 친구"

                }
                // outer 라는 속성 이름으로 ref를 넣겠다.
                this.outer = React.createRef();

            }

            // lifecycle : 컴포넌트가 업데이트될 때
            componentDidUpdate() {
                // 엘리먼트를 생성할 때 outer라는 이름으로 넣어 두었던 ref를 꺼내오기
                this.outer.current.scrollTop = this.outer.current.scrollHeight

            }

            // 말풍선 입력 시간 출력할지 말지 class css로 결정
            getChatTimeClassName(item) {
                const arr = ['chat-time'];
                if(item.isLastChat) {
                    arr.push('last-chat');
                }
                return arr.join(" ");
            }

            // 친구 말풍선 중에서 프로필 사진 + 친구 아이디 출력할지 말지 class css로 결정
            getYourChatWrapperClassName(item) {
                const arr = ['your-chat-wrapper'];
                if(item.isFirstChat) {
                    arr.push('first-chat');
                }
                return arr.join(" ");
            }

            render() {
                const items = this.props.chatList;
                // 상위 컴포넌트에서 말풍선 목록을 받아와서 내용을 하나씩 꺼내면서 요소를 생성하기
                const renderList = items.map((item, index)=> { 
                    let result; 
                    if(item.isMyChat) {
                        result = (
                            <div className="my-chat-container" key={index}>
                                <span className="chat-contents-wrapper">
                                    <div className="chat-box">
                                        <span className={this.getChatTimeClassName(item)} name="chatTime" >
                                            {item.chatTime}
                                        </span>
                                        <span className="my-chat-msg">
                                            {item.contents}
                                        </span>
                                    </div>
                                </span>
                            </div>
                        );
                    } else {
                        result = (
                            <div className={this.getYourChatWrapperClassName(item)} key={index}>
                                <span className="profile-img-wrapper">
                                    <img className="your-profile-img" src="img/default_profile.PNG" alt="default" />
                                </span>
                                <span className="chat-contents-wrapper">
                                    <p className="your-chat-name" name="yourId">{this.state.friendsName}</p>
                                    <div className="chat-box">
                                        <span className="your-chat-msg">
                                            {item.contents}
                                        </span>
                                        <span className={this.getChatTimeClassName(item)} name="chatTime">
                                            {item.chatTime}
                                        </span>
                                    </div>
                                </span>
                            </div>
                        );
                    }
                    return result;
                
                });
                return (
                    <section className="chat-container" ref={this.outer} style={{height: this.props.chatContainerHeight}}>
                        {renderList}
                    </section>
                );
            }
        }
        

        class KakaoSpeak extends React.Component {
            constructor(props) {
                super(props);
                
                // 내부에서만 쓰는 함수는 this를 bind해주지 않아도 됨. 실행 주체가 바뀌는 경우에만 bind 해줌
                this.inputContents = this.inputContents.bind(this);
                this.keyDownHandler = this.keyDownHandler.bind(this);
                this.keyUpHandler = this.keyUpHandler.bind(this);
                this.submitContent = this.submitContent.bind(this);
                // outer 라는 속성 이름으로 ref를 만들겠다
                this.outer = React.createRef();
                this.chatTextarea = React.createRef();

                this.state = {
                    contents: '',
                    keyboardSettings: {korean: 'is-korean', english:'is-english', symbols:'is-symbols'},
                    keyboardToggle: {korean: "ArrowRight", symbols:"End", english: "ArrowDown"},
                    keyboardType: 'is-korean',
                    pressedKeys: [],
                    isShift: false,
                    heightTextarea: '1rem',
                    keyList: { 
                        row1: [
                            {code: 'KeyQ', Korean: 'ㅂ', English: 'q', Symbols: '1', Shift: 'ㅃ'},
                            {code: 'KeyW', Korean: 'ㅈ', English: 'w', Symbols: '2', Shift: 'ㅉ'},
                            {code: 'KeyE', Korean: 'ㄷ', English: 'e', Symbols: '3', Shift: 'ㄸ'},
                            {code: 'KeyR', Korean: 'ㄱ', English: 'r', Symbols: '4', Shift: 'ㄲ'},
                            {code: 'KeyT', Korean: 'ㅅ', English: 't', Symbols: '5', Shift: 'ㅆ'},
                            {code: 'KeyY', Korean: 'ㅛ', English: 'y', Symbols: '6'},
                            {code: 'KeyU', Korean: 'ㅕ', English: 'u', Symbols: '7'},
                            {code: 'KeyI', Korean: 'ㅑ', English: 'i', Symbols: '8'},
                            {code: 'KeyO', Korean: 'ㅐ', English: 'o', Symbols: '9', Shift: 'ㅒ'},
                            {code: 'KeyP', Korean: 'ㅔ', English: 'p', Symbols: '0', Shift: 'ㅖ'},
                        ],
                        row2: [
                            {code: 'KeyA', Korean: 'ㅁ', English: 'a', Symbols: '-'},
                            {code: 'KeyS', Korean: 'ㄴ', English: 's', Symbols: '/'},
                            {code: 'KeyD', Korean: 'ㅇ', English: 'd', Symbols: ':'},
                            {code: 'KeyF', Korean: 'ㄹ', English: 'f', Symbols: ';'},
                            {code: 'KeyG', Korean: 'ㅎ', English: 'g', Symbols: '('},
                            {code: 'KeyH', Korean: 'ㅗ', English: 'h', Symbols: ')'},
                            {code: 'KeyJ', Korean: 'ㅓ', English: 'j', Symbols: '\\'},
                            {code: 'KeyK', Korean: 'ㅏ', English: 'k', Symbols: '&'},
                            {code: 'KeyL', Korean: 'ㅣ', English: 'l', Symbols: '@'},
                        ],
                        row3: [
                            {code: 'KeyZ', Korean: 'ㅋ', English: 'z', Symbols: '\"'},
                            {code: 'KeyX', Korean: 'ㅌ', English: 'x', Symbols: '.'},
                            {code: 'KeyC', Korean: 'ㅊ', English: 'c', Symbols: ','},
                            {code: 'KeyV', Korean: 'ㅍ', English: 'v', Symbols: '?'},
                            {code: 'KeyB', Korean: 'ㅠ', English: 'b', Symbols: '!'},
                            {code: 'KeyN', Korean: 'ㅜ', English: 'n', Symbols: '\''},
                            {code: 'KeyM', Korean: 'ㅡ', English: 'm', Symbols: ''}
                        ]
                    }
                };

            }

            render() {
                // 키보드 안에 들어갈 키 내용물들 요소 만들기
                const keyboardRow1 = this.getKeyboardRow(this.state.keyList.row1);
                const keyboardRow2 = this.getKeyboardRow(this.state.keyList.row2);
                const keyboardRow3 = this.getKeyboardRow(this.state.keyList.row3);

                return (
                    <div ref={this.outer} >

                        <section className="speak">
                            <div className="speak-container">
                                <span><img src="img/plus.png" alt="plus" /></span>
                                <span className="speak-contents-wrapper">
                                    <span><textarea type="text" ref={this.chatTextarea}
                                                    style={{height: this.state.heightTextarea}}
                                                    value={this.state.contents} 
                                                    onInput={this.inputContents} 
                                                    onKeyDown={this.keyDownHandler}
                                                    onKeyUp={this.keyUpHandler}
                                                    onKeyPress={this.submitContent}
                                                ></textarea></span>
                                    <span><img src="img/emoji.png" alt="emoji" /></span>
                                    <span><img src="img/hashtag.png" alt="hashtag" /></span>
                                </span>
                            </div>
                        </section>
                        
                        <section className="keyboard-container">
                            <div id="keyboard" className={this.state.keyboardType}>
                                <div className="row" id="row1">
                                    {keyboardRow1}
                                </div>
                                <div className="row" id="row2">
                                    {keyboardRow2}
                                </div>
                                <div className="row" id="row3">
                                    <div id="ShiftLeft" className={this.getKeyClassName(true, 'ShiftLeft')} style={{width: "11%", margin: "0% 2% 0% 0%"}}>{this.state.keyboardType==this.state.keyboardSettings.symbols ? "#+=" : "⌂"}</div>
                                    {keyboardRow3}
                                    <div id="Backspace" className={this.getKeyClassName(true, 'Backspace')} style={{width: "11%",  margin: "0% 0% 0% 2%"}}>⌫</div>
                                </div>
                                <div className="row" id="row4">
                                    <div id="ToggleKeyboard" className={this.getKeyClassName(true)} style={{width: "11%"}}>{this.state.keyboardType==this.state.keyboardSettings.symbols ? "한글" : "123"}</div>
                                    <div className={this.getKeyClassName(true)} style={{width: "11%"}}>☺️</div>
                                    <div id="Space" className={this.getKeyClassName(false, 'Space')} style={{width: "50%", fontSize: "1rem", fontWeight: "400"}}>간격</div>
                                    <div className={this.getKeyClassName(true)} style={{width: "23%"}}>⏎</div>
                                </div>
                            </div>
                        </section>

                    </div>
                );
            }

            // textarea 내용 입력 시 이벤트
            inputContents(e) {
                // textarea <=> state 값 동기화
                this.setState({
                    contents: e.target.value
                });

                //textarea 최대 높이 설정
                this.setTextareaHeight();

            }

            setTextareaHeight() {
                // textarea 최대 높이 설정
                const contentsHeight = this.chatTextarea.current.scrollHeight;
                const rem = parseFloat(getComputedStyle(document.documentElement).fontSize);
                let maxHeight;
                let x = 6;
                // 5rem보다 작은지 확인, 작으면 4rem보다 작은지 확인, 작으면 3rem보다 작은지 확인, 크면 4rem 그대로 넣기
                while(x > 0) {
                    x--;
                    if(contentsHeight < x * rem) {
                        maxHeight = x * rem;
                    } else {
                        break;
                    }
                }
                this.setState({heightTextarea: x*rem});

            }

            // list 주면 keyboard에서 row 하나를 만들어서 되돌려줌. 한글 or 영어 or 특수문자 출력값도 넣어 주고 className 이나 wrapper 까지 알아서 고려함.
            getKeyboardRow(keyList) {
                const result = keyList.map((item, index)=>{
                        return ( <div id={item.code} className={this.getKeyClassName(false, item.code)} key={item.code} >{this.getKeyTextVal(item)}</div> );
                    });

                return result;
            }

            // keyboard에서 key 요소들 만들 때 className 만들어서 되돌려주기
            getKeyClassName(isSystemKey,code) {
                const cl = ['key'];
                
                // 시스템키일 경우 systemkey 클래스 추가
                if(isSystemKey) {
                    cl.push('systemkey');
                }

                // 눌려 있는 키들 css 적용 클래스 추가
                if(this.state.pressedKeys.includes(code)) {
                    if(isSystemKey) {
                        cl.push('systemkeyPress');
                    } else {
                        cl.push('keyPress');
                    }
                }

                return cl.join(" ");
            }

            // type 에 따라서 한글/영어/특수문자 되돌려주기
            getKeyTextVal(item) {
                let result;
                if(this.state.isShift && this.state.keyboardType == this.state.keyboardSettings.korean) {   // 한글이면서 shift 누르면
                    result = item.Shift || item.Korean;
                } else if(this.state.keyboardType == this.state.keyboardSettings.korean) {     // 그냥 한글이면
                    result = item.Korean;
                } else if(this.state.keyboardType == this.state.keyboardSettings.symbols) {     // 특수문자면
                    result = item.Symbols;
                } else if(this.state.keyboardType == this.state.keyboardSettings.english) {     // 영어면
                    result = item.English;
                } else {
                    console.log('uncaught keyboard type');
                    result = 'error';
                }
                return result;
            }

            // 말풍선 옆에 붙을 시간 형식으로 바꿔주기
            chatTimeFormatter(t) {
                const h = t.getHours() < 13 ? t.getHours() : t.getHours()-12;
                const m = t.getMinutes() > 9 ? t.getMinutes() : '0' + t.getMinutes();
                const n = t.getHours() < 12 ? '오전' : '오후';
                // template literal: "`" 로 감싸고, 그 안에 "${변수명}" 넣으면 변수 값이 그대로 출력
                const time = `${n} ${h}:${m}`;
                // state 로 들고 있으면 이걸 참조하는 말풍선들은 시간이 지날 때마다 함께 업데이트 되고, 결국 모든 말풍선이 같은 시각을 가르키게 됨.
                return time;
            }

                // |\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/| 키보드 이벤트 |\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|/\|
            // 키보드 누름 이벤트
            keyDownHandler(e) {
                // keyboard press event handler
                this.keyboardKeyDownHandler(e);
            }
            
            // 키보드 뗌 이벤트
            keyUpHandler(e) {
                this.keyboardKeyUpHandler(e);
            }
            // =================== keyboard event start ======================
            keyboardKeyDownHandler(e) {
                console.log(e);
                this.effectKeyDown(e.code);  // 키 누르면 css 변경
                this.changeKeyboardType(e.code);   // 문자나 레이아웃 변경
                this.effectSymbolKeyDown(e);  // 시스템키들 개별 이벤트
                this.effectShiftKeyDown(e); // 한글 쌍자음 이벤트 - shift 누를 때
                // this.submitContent(e);  // 엔터키 이벤트 => onKeyDown 이벤트로부터 onKeyPress 이벤트로 옮김. 이유는 해당 함수에 각주로.

            }

            // enter는 상위 컴포넌트로 submit하고 shif+enter는 다음 줄로 넘어가기
            submitContent(e) {
                console.log(e);
                // 한글은 입력할 때 자음, 모음, 받침 등을 조합해서 만든다.
                // 이때 아직 조합 중인 글자는 커서가 깜빡이고 밑에 밑줄이 그어 있다.
                // 이 상태에서 엔터나 스페이스, 백스페이스 등을 누르면 두 번 입력된다.
                // 이러한 현상을 해결하려면 KeyboardEvent에서 isComposing 속성을 확인하면 된다.
                // 조합 중인 글자는 isComposing이 true다.
                // 조합이 끝난 글자는 false다.
                // 따라서 이벤트는 조합이 끝난 글자 false에만 작동하도록 만든다.
                if(e.isComposing) return;   
                if(e.code=='Enter') {
                    if(e.shiftKey) {
                        // shift + enter 입력했을 때
                        console.log('next line');
                        // 그러고 보니 지금 textarea라서 엔터 누르면 다음 줄로 넘어가는 건 아무것도 하지 않아도 저절로 그렇게 되네. shift + enter 눌렀을 때 submit 되는 기능만 만들어 두면 될 듯.
                    } else {
                        // props 를 그대로 참조하면 그 props를 넣어주는 상위 컴포넌트에서 state가 바뀔 때마다 그 값을 참조하고 있는 다른 요소들도 값이 함께 바뀌게 됨.
                        // 즉 모든 말풍선이 같은 시각을 가르키게 됨.
                        // 따라서 Date 객체가 state와는 별개의 객체로 존재해야 함.
                        // 따라서 app에서 들고 있는 state 는 UTC 타임만 들고 있고, 다른 데에서 사용할 때는 그 UTC를 파라미터로 넣은 새로운 Date 객체를 매번 따로 만들어서 사용하기.
                        const t = new Date(this.props.appTime);
                        const time = this.chatTimeFormatter(t);
                        this.props.inputHandler(1, this.state.contents, time);
                        this.setState({contents: ''});
                    }
                }
            }


            // 키 뗄 때 이벤트
            keyboardKeyUpHandler(e) {
                this.effectKeyUp(e.code);
                this.effectShiftKeyUp(e);
                this.effectSymbolKeyUp(e);
            }

            // 키 뗄 때 css 적용 (class로 css 관리)
            effectKeyUp(code) {
                const oldList = this.state.pressedKeys;
                const newList = oldList.filter((item)=>{ 
                                    if(item == code) {return false;} 
                                    else {return true;}
                                });
                this.setState({pressedKeys: newList});
            }

            
            // 키 누를 때 css 적용 (class로 css 관리)
            effectKeyDown(code) {
                const oldList = this.state.pressedKeys;
                const newList = [...oldList, code];
                this.setState({pressedKeys: newList});

            }

            // 키보드 한글/영어/특수문자 전환
            changeKeyboardType(code) {
                const isToggle = (code == this.state.keyboardToggle.korean || 
                            code == this.state.keyboardToggle.english  || 
                            code == this.state.keyboardToggle.symbols  );
                if(isToggle) {
                    if(this.state.keyboardType == this.state.keyboardSettings.symbols) {
                        // keyboardType이 이미 특수문자일 경우 키보드 레이아웃 원래대로 되돌리기
                        this.toggleSymbolsLayout(true);
                    }
                } else {
                    // 누른 키가 한영 변환이나 특수문자 변환이 아니면 그대로 끝내기
                    return;
                }
                
                // toggle 키에 따라서 keyboard type 바꿔주기
                if(code == this.state.keyboardToggle.korean) {
                    this.setState({keyboardType: this.state.keyboardSettings.korean});
                } else if(code == this.state.keyboardToggle.english) {
                    this.setState({keyboardType: this.state.keyboardSettings.english});
                } else if(code == this.state.keyboardToggle.symbols) {
                    this.setState({keyboardType: this.state.keyboardSettings.symbols});
                    // keyboardType을 특수문자로 바꿀 경우 KeyZ 를 row2로 옮기기
                    this.toggleSymbolsLayout(false);
                }
                
            }

            // 키보드가 특수문자일 경우 레이아웃이 바뀜.
            toggleSymbolsLayout(flag) {
                // keyList 전체 복사해 오기 spread syntax 배열이랑 객체 둘 다 가능. [...arr] / {...obj} 
                const kl = {...this.state.keyList};
                if(flag) {  // keyboardType이 특수문자일 경우 키보드 레이아웃 원래대로 되돌리기
                    // row2에서 마지막 요소 꺼내기
                    const keyZ = kl.row2.pop();
                    // 배열 row3 에서 0번째 인덱스부터 0개 요소를 제거한 뒤에 그 자리에 keyZ를 넣기
                    kl.row3.splice(0, 0, keyZ);
                    // 배열 row3에 요소 하나 추가
                    kl.row3.push({code: 'KeyM', Korean: 'ㅡ', English: 'm', Symbols: ''});
                    
                } else {    // keyboardType을 특수문자로 바꿀 경우 KeyZ 를 row2로 옮기기
                    // 배열에서 첫 요소 제거 + 반환 (mutating original array)
                    const relocatingKey = kl.row3.shift();
                    // 배열에서 마지막 요소 제거 + 반환 (mutating original array)
                    kl.row3.pop();
                    // 꺼낸 요소 넣기
                    kl.row2.push(relocatingKey);
                }
                this.setState({keyList:kl});
            }

            // 특수문자 css 개별 이벤트
            effectSymbolKeyDown(e) {
                // 키보드가 특수문자일 경우 경우에만 작동
                if(!this.state.keyboardType == this.state.keyboardSettings.symbols) {
                    return;
                }

                const key = this.getSymbolKeyMapping(e);
                
                if(key) {
                    this.effectKeyDown(key);
                }
                return;

            }

            // 특수문자 css 개별 이벤트
            effectSymbolKeyUp(e) {
                // 키보드가 특수문자일 경우 경우에만 작동
                if(!this.state.keyboardType == this.state.keyboardSettings.symbols) {
                    return;
                }

                const key = this.getSymbolKeyMapping(e);
                
                if(key) {
                    this.effectKeyUp(key);
                }
                return;

            }

            // 코드는 넣어주면 해당 특수문자키가 어떤 일반키랑 맵핑인지 뱉어줌
            getSymbolKeyMapping(e) {
                let key = "";

                // shift 눌러야 하는 특수문자들
                if(e.shiftKey) {
                    // ??? 물음표 이벤트
                    if(e.code == 'Slash') {
                        key = "KeyV";
                    }
                    // !!! 느낌표 이벤트
                    if(e.code == 'Digit1') { 
                        key = "KeyB";
                    }
                    // """ 쌍따옴표 이벤트
                    if(e.code == 'Quote') {
                        key = "KeyZ";
                    }
                } else {
                    // ... 쩜쩜쩜 이벤트
                    if(e.code == 'Period') {
                        key = "KeyX";
                    }
                    // ,,, 쉼표 이벤트
                    if(e.code == 'Comma') {
                        key = "KeyC";
                    }
                    // ''' 따옴표 이벤트
                    if(e.code == 'Quote') {
                        key = "KeyN";
                    }
                }
                return key;
            }
            // 쌍자음 효과 - shift key 누를 때
            effectShiftKeyDown(e) {
                if(e.code == 'ShiftLeft') { // 왼쪽 shift키 이벤트
                    this.setState({isShift: true});
                }

                
            }

            // 쌍자음 효과 - shift key 뗄 때
            effectShiftKeyUp(e) {
                if(e.code == 'ShiftLeft') { // 왼쪽 shift키 이벤트
                    this.setState({isShift: false});
                }

            }

        }
// end of speak section !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        ReactDOM.render(<App />, document.querySelector('#root1'));

    </script>
</body>
</html>